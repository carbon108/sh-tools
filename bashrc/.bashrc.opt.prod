#
# To be sourced in PRODUCTION containers
#

# If not running interactively, don't do anything
case $- in
    *i*) ;;
      *) return;;
esac

# enable color support of ls and also add handy aliases
if [ -x /usr/bin/dircolors ]; then
    alias ls='ls --color=auto'
    alias dir='dir --color=auto'
    alias vdir='vdir --color=auto'
    alias grep='grep --color=auto'
    alias fgrep='fgrep --color=auto'
    alias egrep='egrep --color=auto'
fi

alias c="clear"
alias l='ls -lah'
alias la='ls -lAh'
alias ll='ls -lh'

# Tools ##########################################################################

hi(){
local pattern=$1
[[ -n $pattern ]] \
    && history | cut -c 8- | tail -n 21 | grep $pattern \
    && return
history | cut -c 8- | tail -n 21
}

hiii(){
local pattern=$1
[[ -n $pattern ]] \
    && history | cut -c 8- | grep $pattern \
    && return
history | cut -c 8-
}

# PROMPT Wrapper =================================================================
# Custom Bash prompt =============================================================
# Colors reference: https://misc.flogisoft.com/bash/tip_colors_and_formatting

p_tag=${BEE_TAG:+"\[\e[34m\]$BEE_TAG\[\e[m\]"}
p_separator="\[\e[33m\]·\[\e[m\]"
p_path="\[\e[90m\]\w\[\e[m\]"
bee_symbol=$(echo -e "\U0001F41D")
flag_symbol=$(echo -e "\U0001F6A9")

prompt_header="\n"
prompt_header+=${BEE_TAG:+"$p_tag $p_separator "}
prompt_header+="$p_path"

# SIMPLE version:
#     export PS1="$prompt_header\n$bee_symbol \h \[\e[33m\]❯ \[\e[m\]"

PROMPT_COMMAND=__prompt_command # Re-generates PS1 after each shell command call

__prompt_command() {
    local EXIT="$?"             # This needs to be first
    PS1=""

    if [ $EXIT != 0 ]; then # Add red Flag if exit code non 0
        PS1+="$prompt_header\n$bee_symbol \h $flag_symbol\[\e[33m\]❯ \[\e[m\]"
    else
        PS1+="$prompt_header\n$bee_symbol \h \[\e[33m\]❯ \[\e[m\]"
    fi

}
# END - PROMPT Wrapper =========================================================